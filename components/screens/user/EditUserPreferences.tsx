import React, { useEffect, useState } from "react";
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  Alert,
  Modal,
} from "react-native";
import { MaterialIcons } from "@expo/vector-icons";
import { Colors } from "@/constants/Colors";
import { useRouter } from "expo-router";
import AsyncStorage from "@react-native-async-storage/async-storage";
import { FontAwesome5 } from "@expo/vector-icons";
import Slider from "@react-native-community/slider";
import LottieView from "lottie-react-native"; 
import {
  fetchUserPreferencesDetails,
  updateUserPreferencesAndRegenerateProgram,
  UserPreferencesPayload,
  UserPreferencesDetail,
  AutoGeneratedProgramResponse,
} from "@/components/services/apiService";

// Icon for the back button
const BackIcon = () => (
  <MaterialIcons
    name="arrow-back-ios"
    size={22}
    color={Colors.dark.tint}
    style={{ marginLeft: -5 }}
  />
);

// Constants for days of the week and selection limits
const DAYS_OF_WEEK = [
  { label: "L", value: 1 }, { label: "M", value: 2 }, { label: "M", value: 3 },
  { label: "J", value: 4 }, { label: "V", value: 5 }, { label: "S", value: 6 },
  { label: "D", value: 7 },
];
const MAX_SELECTED_DAYS = 5;

// Type for the preferences that are editable on this screen
type EditablePreferences = Omit<
  UserPreferencesPayload,
  "name" | "age" | "milestone" | "user_id" | "gender" | "active_program_id"
> & {
  training_days?: number[];
};

// Type for validation error messages
type ValidationErrors = {
  [K in keyof EditablePreferences]?: string;
};

// Initial state for the editable preferences
const initialEditablePreferencesState: EditablePreferences = {
  height_cm: 170,
  weight_kg: 70,
  training_days: [],
  goal: null,
  training_place: null,
  session_length: 60,
};

export default function EditPreferencesScreen() {
  const router = useRouter();

  // State variables
  const [isLoading, setIsLoading] = useState(true); 
  const [isSubmitting, setIsSubmitting] = useState(false); 
  const [apiError, setApiError] = useState<string | null>(null);
  const [userId, setUserId] = useState<string | null>(null);
  const [token, setToken] = useState<string | null>(null);

  const [fullInitialPreferences, setFullInitialPreferences] =
    useState<UserPreferencesDetail | null>(null);
  const [editablePreferences, setEditablePreferences] =
    useState<EditablePreferences>(initialEditablePreferencesState);
  const [validationErrors, setValidationErrors] = useState<ValidationErrors>({});

  const [isConfirmationVisible, setIsConfirmationVisible] = useState(false);

  useEffect(() => {
    const loadInitialData = async () => {
      setIsLoading(true);
      setApiError(null);
      const storedUserId = await AsyncStorage.getItem("userId");
      const storedToken = await AsyncStorage.getItem("token");

      if (storedUserId && storedToken) {
        setUserId(storedUserId);
        setToken(storedToken);
        try {
          const fetchedPrefs = await fetchUserPreferencesDetails(storedUserId, storedToken);
          if (fetchedPrefs.error) {
            setApiError(`Erreur de chargement: ${fetchedPrefs.error}`);
          } else {
            setFullInitialPreferences(fetchedPrefs);
            setEditablePreferences({
              height_cm: fetchedPrefs.height_cm || initialEditablePreferencesState.height_cm,
              weight_kg: fetchedPrefs.weight_kg || initialEditablePreferencesState.weight_kg,
              training_days: fetchedPrefs.training_days || [],
              goal: fetchedPrefs.goal,
              training_place: fetchedPrefs.training_place === "home_with_equipment"
                ? "home_no_equipment"
                : fetchedPrefs.training_place || null,
              session_length: fetchedPrefs.session_length || initialEditablePreferencesState.session_length,
            });
          }
        } catch (e: any) {
          setApiError(e.message || "Erreur de chargement des préférences.");
        }
      } else {
        setApiError("Utilisateur non authentifié. Veuillez vous reconnecter.");
        router.replace("/");
      }
      setIsLoading(false);
    };
    loadInitialData();
  }, [router]);

  const handleSliderChange = (
    field: "height_cm" | "weight_kg" | "session_length",
    value: number
  ) => {
    setEditablePreferences((prev) => ({ ...prev, [field]: Math.round(value) }));
    if (validationErrors[field]) {
      setValidationErrors((prev) => ({ ...prev, [field]: undefined }));
    }
  };

  const createSelectHandler =
    (field: keyof Pick<EditablePreferences, "goal" | "training_place">) =>
    (value: string | null) => {
      setEditablePreferences((prev) => ({ ...prev, [field]: value }));
      if (validationErrors[field]) {
        setValidationErrors((prev) => ({ ...prev, [field]: undefined }));
      }
    };

  const toggleDaySelection = (dayValue: number) => {
    setEditablePreferences((prev) => {
      const currentDays = prev.training_days || [];
      const isSelected = currentDays.includes(dayValue);
      let newSelectedDays: number[];

      if (isSelected) {
        newSelectedDays = currentDays.filter((d) => d !== dayValue);
      } else {
        if (currentDays.length < MAX_SELECTED_DAYS) {
          newSelectedDays = [...currentDays, dayValue];
        } else {
          Alert.alert(
            "Limite atteinte",
            `Vous ne pouvez sélectionner que ${MAX_SELECTED_DAYS} jours d'entraînement au maximum.`
          );
          return prev;
        }
      }
      return { ...prev, training_days: newSelectedDays.sort((a, b) => a - b) };
    });
    if (validationErrors.training_days) {
      setValidationErrors((prev) => ({ ...prev, training_days: undefined }));
    }
  };

  const validateForm = (): boolean => {
    const errors: ValidationErrors = {};
    if (!editablePreferences.goal) errors.goal = "L'objectif est requis.";
    if (!editablePreferences.training_place) errors.training_place = "Le lieu d'entraînement est requis.";
    if (editablePreferences.height_cm === null || editablePreferences.height_cm < 120 || editablePreferences.height_cm > 230) {
      errors.height_cm = "Taille invalide (entre 120 et 230 cm).";
    }
    if (editablePreferences.weight_kg === null || editablePreferences.weight_kg < 30 || editablePreferences.weight_kg > 200) {
      errors.weight_kg = "Poids invalide (entre 30 et 200 kg).";
    }
    const currentTrainingDays = editablePreferences.training_days || [];
    if (currentTrainingDays.length === 0) {
      errors.training_days = "Veuillez sélectionner au moins un jour d'entraînement.";
    } else if (currentTrainingDays.length > MAX_SELECTED_DAYS) {
      errors.training_days = `Vous ne pouvez pas sélectionner plus de ${MAX_SELECTED_DAYS} jours.`;
    }
    if (editablePreferences.session_length === null || editablePreferences.session_length < 30 || editablePreferences.session_length > 120) {
      errors.session_length = "Durée invalide (entre 30 et 120 min).";
    }
    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSubmit = () => {
    if (!validateForm()) {
      Alert.alert("Erreurs de validation", "Veuillez corriger les champs en erreur avant de continuer.");
      return;
    }
    if (!userId || !token) {
      setApiError("Impossible de sauvegarder : les données utilisateur ou le token sont manquants. Veuillez réessayer.");
      Alert.alert("Erreur de session", "Vos informations de session sont incomplètes. Veuillez vous reconnecter et réessayer.");
      return;
    }
    setIsConfirmationVisible(true); 
  };

  const confirmAndSubmitPreferences = async () => {
    setIsConfirmationVisible(false); 
    
    if (!userId || !token) {
        setApiError("Données de session critiques manquantes pour la soumission.");
        setIsSubmitting(false); 
        return;
    }

    setIsSubmitting(true); 
    setApiError(null);

    const preferencesToUpdate: Partial<UserPreferencesPayload> = { ...editablePreferences };

    try {
      const result: AutoGeneratedProgramResponse =
        await updateUserPreferencesAndRegenerateProgram(userId, preferencesToUpdate, token);

      if (result.error) {
        setApiError(result.error);
        Alert.alert("Échec de la mise à jour", `Une erreur est survenue: ${result.error}`);
      } else {
        // Alerte de succès supprimée
        console.log("Préférences mises à jour et programme régénéré avec succès:", result.message || "Opération réussie.");
        // Redirection vers le tableau de bord
        router.replace("/dashboard/dashboard"); // Assurez-vous que "/dashboard" est la bonne route
      }
    } catch (e: any) {
      const errorMessage = e.message || "Une erreur inattendue est survenue lors de la communication avec le serveur.";
      setApiError(errorMessage);
      Alert.alert("Échec de la mise à jour", errorMessage);
    } finally {
      setIsSubmitting(false); 
    }
  };

  if (isLoading) {
    return (
      <View style={styles.centered}>
        <ActivityIndicator size="large" color={Colors.dark.tint} />
        <Text style={styles.loadingText}>Chargement des préférences...</Text>
      </View>
    );
  }

  const goalHandler = createSelectHandler("goal");
  const trainingPlaceHandler = createSelectHandler("training_place");
  const currentSelectedDays = editablePreferences.training_days || [];

  return (
    <View style={styles.mainContainer}>
      <View style={styles.headerBar}>
        <TouchableOpacity onPress={() => router.back()} style={styles.headerButton}>
          <BackIcon />
        </TouchableOpacity>
        <Text style={styles.title}>Modifier Préférences & Programme</Text>
        <View style={styles.headerButtonPlaceholder} />
      </View>

      {apiError && !isSubmitting && (
        <Text style={styles.globalErrorText}>{apiError}</Text>
      )}

      <View style={styles.formContent}>
        <View style={styles.formGroup}>
          <Text style={styles.label}>Objectif Principal</Text>
          <View style={styles.goalButtonGroup}>
            <TouchableOpacity
              style={[styles.goalButton, editablePreferences.goal === "lose weight" && styles.selectedGoalButton]}
              onPress={() => goalHandler("lose weight")}
            >
              <FontAwesome5 name="weight" size={18} color={editablePreferences.goal === "lose weight" ? Colors.dark.background : Colors.dark.text}/>
              <Text style={[styles.goalButtonText, editablePreferences.goal === "lose weight" && styles.selectedGoalButtonText]}>Perdre du gras</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.goalButton, editablePreferences.goal === "gain muscle" && styles.selectedGoalButton]}
              onPress={() => goalHandler("gain muscle")}
            >
              <FontAwesome5 name="dumbbell" size={18} color={editablePreferences.goal === "gain muscle" ? Colors.dark.background : Colors.dark.text}/>
              <Text style={[styles.goalButtonText, editablePreferences.goal === "gain muscle" && styles.selectedGoalButtonText]}>Me muscler</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.goalButton, editablePreferences.goal === "improve health" && styles.selectedGoalButton]}
              onPress={() => goalHandler("improve health")}
            >
              <FontAwesome5 name="heartbeat" size={18} color={editablePreferences.goal === "improve health" ? Colors.dark.background : Colors.dark.text}/>
              <Text style={[styles.goalButtonText, editablePreferences.goal === "improve health" && styles.selectedGoalButtonText]}>Santé</Text>
            </TouchableOpacity>
          </View>
          {validationErrors.goal && (<Text style={styles.errorText}>{validationErrors.goal}</Text>)}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Taille ({editablePreferences.height_cm || 0} cm)</Text>
          <Slider
            style={styles.slider} value={editablePreferences.height_cm || initialEditablePreferencesState.height_cm!}
            minimumValue={120} maximumValue={230} step={1}
            onValueChange={(val) => handleSliderChange("height_cm", val)}
            minimumTrackTintColor={Colors.dark.tint} maximumTrackTintColor={Colors.dark.secondary} thumbTintColor={Colors.dark.tint}
          />
          {validationErrors.height_cm && (<Text style={styles.errorText}>{validationErrors.height_cm}</Text>)}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Poids ({editablePreferences.weight_kg || 0} kg)</Text>
          <Slider
            style={styles.slider} value={editablePreferences.weight_kg || initialEditablePreferencesState.weight_kg!}
            minimumValue={30} maximumValue={200} step={1}
            onValueChange={(val) => handleSliderChange("weight_kg", val)}
            minimumTrackTintColor={Colors.dark.tint} maximumTrackTintColor={Colors.dark.secondary} thumbTintColor={Colors.dark.tint}
          />
          {validationErrors.weight_kg && (<Text style={styles.errorText}>{validationErrors.weight_kg}</Text>)}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>
            Jours d'entraînement
            {currentSelectedDays.length >= MAX_SELECTED_DAYS && (<Text style={styles.limitReachedText}> (Max {MAX_SELECTED_DAYS} atteints)</Text>)}
          </Text>
          <View style={styles.daysContainer}>
            {DAYS_OF_WEEK.map((day) => {
              const isSelected = currentSelectedDays.includes(day.value);
              const isDisabled = !isSelected && currentSelectedDays.length >= MAX_SELECTED_DAYS;
              return (
                <TouchableOpacity
                  key={day.value}
                  style={[styles.dayButton, isSelected && styles.selectedDayButton, isDisabled && styles.disabledDayButton]}
                  onPress={() => toggleDaySelection(day.value)} disabled={isDisabled}
                >
                  <Text style={[styles.dayButtonText, isSelected && styles.selectedDayButtonText, isDisabled && styles.disabledDayButtonText]}>{day.label}</Text>
                </TouchableOpacity>
              );
            })}
          </View>
          {validationErrors.training_days && (<Text style={styles.errorText}>{validationErrors.training_days}</Text>)}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Lieu d'entraînement</Text>
          <View style={styles.buttonGroup}>
            <TouchableOpacity
              style={[styles.choiceButton, editablePreferences.training_place === "gym" && styles.selectedChoiceButton]}
              onPress={() => trainingPlaceHandler("gym")}
            >
              <Text style={[styles.choiceButtonText, editablePreferences.training_place === "gym" && styles.selectedChoiceButtonText]}>Salle</Text>
            </TouchableOpacity>
            <TouchableOpacity
              style={[styles.choiceButton, editablePreferences.training_place === "home_no_equipment" && styles.selectedChoiceButton]}
              onPress={() => trainingPlaceHandler("home_no_equipment")}
            >
              <Text style={[styles.choiceButtonText, editablePreferences.training_place === "home_no_equipment" && styles.selectedChoiceButtonText]}>Maison</Text>
            </TouchableOpacity>
          </View>
          {validationErrors.training_place && (<Text style={styles.errorText}>{validationErrors.training_place}</Text>)}
        </View>

        <View style={styles.formGroup}>
          <Text style={styles.label}>Durée de session ({editablePreferences.session_length || 0} min)</Text>
          <Slider
            style={styles.slider} value={editablePreferences.session_length || initialEditablePreferencesState.session_length!}
            minimumValue={30} maximumValue={120} step={30}
            onValueChange={(val) => handleSliderChange("session_length", val)}
            minimumTrackTintColor={Colors.dark.tint} maximumTrackTintColor={Colors.dark.secondary} thumbTintColor={Colors.dark.tint}
          />
          {validationErrors.session_length && (<Text style={styles.errorText}>{validationErrors.session_length}</Text>)}
        </View>
      </View>

      <TouchableOpacity
        style={[styles.button, isSubmitting && styles.buttonDisabled]} 
        onPress={handleSubmit}
        disabled={isSubmitting || isLoading} 
      >
        <Text style={styles.buttonText}>Sauvegarder et Régénérer</Text>
      </TouchableOpacity>

      <Modal
        animationType="fade"
        transparent={true}
        visible={isConfirmationVisible}
        onRequestClose={() => setIsConfirmationVisible(false)}
      >
        <View style={styles.modalOverlay}>
            <View style={styles.modalContainer}>
                <Text style={styles.modalTitle}>Confirmer la Sauvegarde</Text>
                <Text style={styles.modalMessage}>
                    Sauvegarder vos nouvelles préférences supprimera et régénérera votre programme actif actuel. Êtes-vous sûr de vouloir continuer ?
                </Text>
                <View style={styles.modalButtonContainer}>
                    <TouchableOpacity
                        style={[styles.modalButton, styles.modalCancelButton]}
                        onPress={() => setIsConfirmationVisible(false)}
                        disabled={isSubmitting} 
                    >
                        <Text style={styles.modalCancelButtonText}>Annuler</Text>
                    </TouchableOpacity>
                    <TouchableOpacity
                        style={[styles.modalButton, styles.modalConfirmButton]}
                        onPress={confirmAndSubmitPreferences}
                        disabled={isSubmitting} 
                    >
                        <Text style={styles.modalConfirmButtonText}>Confirmer</Text>
                    </TouchableOpacity>
                </View>
            </View>
        </View>
      </Modal>

      <Modal
        animationType="fade"
        transparent={true}
        visible={isSubmitting} 
      >
        <View style={styles.loadingModalOverlay}>
          <LottieView
            source={require("../../../assets/animations/loading.json")}
            autoPlay
            loop={true} 
            style={styles.lottieAnimation}
          />
          <Text style={styles.loadingModalText}>Mise à jour en cours...</Text>
        </View>
      </Modal>
    </View>
  );
}

// Styles for the component (styles remain largely the same as EditPreferencesScreen_v3_lottie_loading, 
// ensuring modal styles are present and formScrollView/formContentContainer are adapted or removed)
const styles = StyleSheet.create({
  mainContainer: {
    flex: 1,
    backgroundColor: Colors.dark.background,
    paddingTop: 40,
  },
  headerBar: {
    flexDirection: "row",
    justifyContent: "space-between",
    alignItems: "center",
    paddingHorizontal: 20,
    paddingVertical: 10,
    borderBottomWidth: 1,
    borderBottomColor: Colors.dark.card,
  },
  headerButton: {
    padding: 5,
    justifyContent: 'center',
    alignItems: 'center',
    width: 30, 
  },
  headerButtonPlaceholder: { 
    width: 30, 
  },
  title: {
    fontSize: 18, 
    fontWeight: "bold",
    color: Colors.dark.title,
    textAlign: "center",
  },
  centered: { 
    flex: 1,
    justifyContent: "center",
    alignItems: "center",
    backgroundColor: Colors.dark.background,
    paddingHorizontal: 20,
  },
  loadingText: { 
    marginTop: 10,
    fontSize: 15,
    color: Colors.dark.text,
  },
  globalErrorText: {
    color: "#FF6B6B",
    textAlign: "center",
    marginVertical: 10,
    paddingHorizontal: 20,
    fontSize: 13,
    lineHeight: 18,
  },
  formContent: { 
    flex: 1, 
    paddingHorizontal: 20, 
    justifyContent: "space-around", 
    paddingBottom: 10, 
  },
  formGroup: {
    marginBottom: 12, 
  },
  label: {
    fontSize: 14,
    color: Colors.dark.text,
    marginBottom: 8, 
    fontWeight: "600",
  },
  limitReachedText: {
    fontSize: 12,
    color: Colors.dark.secondary,
    fontWeight: "normal",
  },
  errorText: {
    color: "#FF8E8E", 
    fontSize: 12,
    marginTop: 5,
  },
  buttonGroup: { 
    flexDirection: "row",
    justifyContent: "space-around", 
  },
  choiceButton: {
    backgroundColor: Colors.dark.card,
    paddingVertical: 12, 
    paddingHorizontal: 15,
    borderRadius: 8, 
    borderWidth: 1,
    borderColor: Colors.dark.secondary,
    alignItems: "center",
    flex: 1, 
    marginHorizontal: 5, 
  },
  selectedChoiceButton: {
    backgroundColor: Colors.dark.tint,
    borderColor: Colors.dark.tint,
  },
  choiceButtonText: {
    color: Colors.dark.text,
    fontSize: 14, 
    fontWeight: "600",
  },
  selectedChoiceButtonText: {
    color: Colors.dark.background, 
  },
  goalButtonGroup: {
    flexDirection: "row",
    justifyContent: "space-between",
    marginBottom: 8,
  },
  goalButton: {
    backgroundColor: Colors.dark.card,
    flex: 1,
    marginHorizontal: 4,
    paddingVertical: 10, 
    borderRadius: 8,
    borderWidth: 1,
    borderColor: Colors.dark.secondary,
    alignItems: "center",
    justifyContent: "center",
    minHeight: 70, 
  },
  selectedGoalButton: {
    backgroundColor: Colors.dark.tint,
    borderColor: Colors.dark.tint,
  },
  goalButtonText: {
    color: Colors.dark.text,
    fontSize: 12, 
    fontWeight: "600",
    marginTop: 5, 
    textAlign: "center",
  },
  selectedGoalButtonText: {
    color: Colors.dark.background,
  },
  slider: {
    width: "100%",
    height: 40, 
  },
  daysContainer: {
    flexDirection: "row",
    justifyContent: "space-around", 
    alignItems: "center",
    marginTop: 8,
  },
  dayButton: {
    paddingVertical: 8,
    paddingHorizontal: 10,
    borderRadius: 20, 
    borderWidth: 1.5, 
    borderColor: Colors.dark.secondary,
    backgroundColor: Colors.dark.card,
    alignItems: "center",
    justifyContent: "center",
    width: 38, 
    height: 38, 
  },
  selectedDayButton: {
    backgroundColor: Colors.dark.primary,
    borderColor: Colors.dark.primary,
  },
  disabledDayButton: {
    backgroundColor: Colors.dark.card,
    borderColor: Colors.dark.secondary,
    opacity: 0.5,
  },
  dayButtonText: {
    color: Colors.dark.text,
    fontSize: 14,
    fontWeight: "bold",
  },
  selectedDayButtonText: {
    color: Colors.dark.background,
  },
  disabledDayButtonText: {
    color: Colors.dark.text, 
    opacity: 0.7,
  },
  button: { 
    backgroundColor: Colors.dark.tint,
    paddingVertical: 14, 
    borderRadius: 8,
    alignItems: "center",
    marginHorizontal: 20, 
    marginTop: 10, 
    marginBottom: 20, 
  },
  buttonDisabled: {
    backgroundColor: Colors.dark.secondary, 
    opacity: 0.8,
  },
  buttonText: {
    color: Colors.dark.background,
    fontSize: 16, 
    fontWeight: "bold",
  },
  modalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.6)",
    justifyContent: "center",
    alignItems: "center",
  },
  modalContainer: {
    width: "85%",
    maxWidth: 350,
    backgroundColor: Colors.dark.card,
    borderRadius: 15,
    padding: 20,
    alignItems: "center",
    shadowColor: "#000",
    shadowOffset: { width: 0, height: 2 },
    shadowOpacity: 0.25,
    shadowRadius: 3.84,
    elevation: 5,
  },
  modalTitle: {
    fontSize: 20,
    fontWeight: "bold",
    color: Colors.dark.title,
    marginBottom: 15,
    textAlign: "center",
  },
  modalMessage: {
    fontSize: 15,
    color: Colors.dark.text,
    textAlign: "center",
    marginBottom: 25,
    lineHeight: 22,
  },
  modalButtonContainer: {
    flexDirection: "row",
    justifyContent: "space-around",
    width: "100%",
  },
  modalButton: {
    borderRadius: 20,
    paddingVertical: 10,
    paddingHorizontal: 20,
    flex: 1,
    alignItems: "center",
    marginHorizontal: 5,
  },
  modalCancelButton: {
    backgroundColor: Colors.dark.secondary,
    borderWidth: 1,
    borderColor: Colors.dark.secondary,
  },
  modalCancelButtonText: {
    color: Colors.dark.text,
    fontWeight: "bold",
    fontSize: 15,
  },
  modalConfirmButton: {
    backgroundColor: Colors.dark.primary,
  },
  modalConfirmButtonText: {
    color: Colors.dark.background,
    fontWeight: "bold",
    fontSize: 15,
  },
  loadingModalOverlay: {
    flex: 1,
    backgroundColor: "rgba(0, 0, 0, 0.8)", 
    justifyContent: "center",
    alignItems: "center",
  },
  lottieAnimation: {
    width: 200, 
    height: 200, 
  },
  loadingModalText: {
    marginTop: 10,
    fontSize: 16,
    color: Colors.dark.text, 
    fontWeight: "bold",
  },
});
