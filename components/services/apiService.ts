import AsyncStorage from "@react-native-async-storage/async-storage";

const API_BASE_URL = "https://begainer-api.onrender.com/api";

// Interface definitions
export interface User {
  id: string;
  email?: string;
  name?: string;
}

export interface AuthResponse {
  token?: string;
  user?: User;
  id?: string;
  error?: string;
  name?: string;
}

export interface UserPreferencesResponse {
  user_id: string;
  name: string;
  error?: string;
}

export interface UserPreferencesPayload {
  user_id: string | null;
  name: string | null;
  gender: string | null;
  age: number | null;
  height_cm: number | null;
  weight_kg: number | null;
  training_days?: number[];
  goal: string | null;
  training_place: string | null;
  session_length: number | null;
  milestone: string | null;
  active_program_id?: string | null;
}

export interface ExerciseDefinition {
  id: string;
  name: string;
  description: string | null;
  muscle_group: string;
  image_url?: string | null;
}

export interface SessionExercise {
  id: string; // ID de l'entrée session_exercise (unique pour cette instance dans la session)
  exercise_id: string; // ID de l'exercice (référence à ExerciseDefinition)
  name: string; // Nom de l'exercice (peut être redondant si on le récupère toujours via exercise_id)
  description?: string | null; // Description (à récupérer via exercise_id)
  muscle_group: string; // Groupe musculaire (peut être redondant)
  sets: number;
  reps: number;
  rest_time: number;
  image_url?: string | null; // URL de l'image (à récupérer via exercise_id)
}
export interface ProgramSession {
  id: string;
  program_id: string;
  name: string;
  day_number: number;
  exercise_count: number;
  exercises: SessionExercise[];
}
export interface UserProgram {
  id: string;
  user_id: string;
  name: string;
  goal: string;
  duration_weeks: number;
  start_date: string;
  error?: string;
}

export interface UserPreferencesDetail extends UserPreferencesPayload {
  id?: string;
  error?: string;
}

export interface AutoGeneratedProgramResponse extends UserProgram {
  sessions?: ProgramSession[];
  message?: string;
}

// Helper to handle API responses
const handleApiResponse = async <T>(response: Response): Promise<T> => {
  const responseText = await response.text();
  let dataJson: any;

  try {
    if (responseText) {
      dataJson = JSON.parse(responseText);
    }
  } catch (parseError) {
    if (!response.ok) {
      return { error: `Erreur serveur (${response.status}). Réponse non lisible.` } as T;
    }
    return { error: "Réponse du serveur au format inattendu (JSON invalide)." } as T;
  }

  if (!response.ok) {
    if (!dataJson) {
        return { error: `Erreur HTTP ${response.status}: ${response.statusText || "Erreur inconnue du serveur"}` } as T;
    }
    return dataJson as T;
  }

  if (response.status === 204 && !dataJson) {
    return {} as T;
  }

  return dataJson as T;
};

// Fetches detailed user preferences
export const fetchUserPreferencesDetails = async (
  userId: string,
  token: string
): Promise<UserPreferencesDetail> => {
  const response = await fetch(`${API_BASE_URL}/user-preferences/${userId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleApiResponse<UserPreferencesDetail>(response);
};

// Deletes a program by its ID
export const deleteProgram = async (
  programId: string,
  token: string
): Promise<{ message?: string; error?: string }> => {
  const response = await fetch(`${API_BASE_URL}/programs/${programId}`, {
    method: "DELETE",
    headers: { Authorization: `Bearer ${token}` },
  });
  if (response.status === 204) {
    return { message: "Programme supprimé avec succès." };
  }
  return handleApiResponse<{ message?: string; error?: string }>(response);
};

export const submitUserPreferencesAndGenerate = async (
  preferences: UserPreferencesPayload,
  token: string
): Promise<AutoGeneratedProgramResponse> => {
  if (!preferences.user_id) {
    return { error: "ID utilisateur manquant.", id: '', user_id: '', name: '', goal: '', duration_weeks: 0, start_date: '' };
  }

  let accumulatedError = "";

  try {
    const currentPrefsDetails = await fetchUserPreferencesDetails(preferences.user_id, token);
    if (currentPrefsDetails && currentPrefsDetails.active_program_id && !currentPrefsDetails.error) {
      const oldProgramId = currentPrefsDetails.active_program_id;
      console.log(`submitUserPreferencesAndGenerate: Tentative de suppression de l'ancien programme actif: ${oldProgramId}`);
      const deleteResponse = await deleteProgram(oldProgramId, token);
      if (deleteResponse.error) {
        const errMsg = `Échec de la suppression de l'ancien programme ${oldProgramId}: ${deleteResponse.error}.`;
        console.warn(`submitUserPreferencesAndGenerate: ${errMsg}`);
        accumulatedError += errMsg + "\n";
      } else {
        console.log(`submitUserPreferencesAndGenerate: Ancien programme ${oldProgramId} supprimé avec succès.`);
      }
    }
  } catch (e: any) {
    const errMsg = `Erreur lors de la récupération/suppression de l'ancien programme actif: ${e.message}.`;
    console.warn(`submitUserPreferencesAndGenerate: ${errMsg}`);
    accumulatedError += errMsg + "\n";
  }

  const initialPrefsResponse = await fetch(`${API_BASE_URL}/user-preferences`, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(preferences),
  });

  const initialPrefsResult = await handleApiResponse<UserPreferencesDetail>(initialPrefsResponse);

  if (initialPrefsResult.error) {
      accumulatedError += `Échec de la soumission des préférences initiales: ${initialPrefsResult.error || initialPrefsResponse.statusText}`;
      return { error: accumulatedError.trim(), id: '', user_id: preferences.user_id, name: '', goal: '', duration_weeks: 0, start_date: '' };
  }

  const autoGenerateCallResponse = await fetch(
    `${API_BASE_URL}/programs/auto-generate`,
    {
      method: "POST",
      headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
      body: JSON.stringify({ user_id: preferences.user_id }),
    }
  );
  const genResponse = await handleApiResponse<{message?: string; program_id?: string; error?: string}>(autoGenerateCallResponse);

  if (genResponse.error || !genResponse.program_id) {
    accumulatedError += genResponse.error || "ID de programme manquant après génération";
    return { error: accumulatedError.trim(), id: '', user_id: preferences.user_id || '', name: '', goal: '', duration_weeks: 0, start_date: '' };
  }

  const newProgramId = genResponse.program_id;

  const finalPreferencesPayload: UserPreferencesPayload = {
    ...initialPrefsResult,
    active_program_id: newProgramId,
  };

  const setActiveProgramResponse = await fetch(`${API_BASE_URL}/user-preferences/${preferences.user_id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(finalPreferencesPayload),
  });

  const finalPrefsUpdateResult = await handleApiResponse<UserPreferencesDetail>(setActiveProgramResponse);

  const programDetails = await fetchProgramById(newProgramId, token);
  let sessionsArray: ProgramSession[] = [];
  if (!programDetails.error) {
      const sessionsData = await fetchSessionsWithExercisesForProgram(newProgramId, token);
      if (Array.isArray(sessionsData)) {
          sessionsArray = sessionsData;
      } else if(sessionsData.error) {
          accumulatedError += `Erreur chargement sessions: ${sessionsData.error}\n`;
      }
  } else {
      accumulatedError += `Erreur chargement détails programme: ${programDetails.error}\n`;
  }

  if (finalPrefsUpdateResult.error) {
      accumulatedError += `Programme généré (ID: ${newProgramId}) mais échec de la définition comme actif: ${finalPrefsUpdateResult.error}`;
  }

  return {
    ...(programDetails.error
      ? {
          id: newProgramId,
          user_id: preferences.user_id,
          name: "Détails indisponibles",
          goal: preferences.goal || "N/A",
          duration_weeks: 0,
          start_date: "",
        }
      : programDetails),
    sessions: sessionsArray,
    message: genResponse.message,
    error: accumulatedError ? accumulatedError.trim() : undefined
  };
};

export const updateUserPreferencesAndRegenerateProgram = async (
  userId: string,
  preferencesToUpdate: Partial<UserPreferencesPayload>,
  token: string
): Promise<AutoGeneratedProgramResponse> => {
  let accumulatedError = "";

  let currentFullPrefs: UserPreferencesDetail;
  try {
    const prefsDetails = await fetchUserPreferencesDetails(userId, token);
    if (prefsDetails.error) {
      return { error: `Erreur lors de la récupération des préférences actuelles: ${prefsDetails.error}`, id: '', user_id: userId, name: '', goal: '', duration_weeks: 0, start_date: '' };
    }
    currentFullPrefs = prefsDetails;
  } catch (e: any) {
    return { error: `Exception lors de la récupération des préférences: ${e.message}`, id: '', user_id: userId, name: '', goal: '', duration_weeks: 0, start_date: '' };
  }

  if (currentFullPrefs.active_program_id) {
    const oldProgramId = currentFullPrefs.active_program_id;
    console.log(`updateUserPreferencesAndRegenerateProgram: Tentative de suppression de l'ancien programme actif: ${oldProgramId}`);
    const deleteResponse = await deleteProgram(oldProgramId, token);
    if (deleteResponse.error) {
      const errMsg = `Échec de la suppression de l'ancien programme ${oldProgramId}: ${deleteResponse.error}.`;
      console.warn(`updateUserPreferencesAndRegenerateProgram: ${errMsg}`);
      accumulatedError += errMsg + "\n";
    } else {
      console.log(`updateUserPreferencesAndRegenerateProgram: Ancien programme ${oldProgramId} supprimé avec succès.`);
    }
  }

  const prefsForFirstPut: UserPreferencesPayload = {
    ...currentFullPrefs,
    ...preferencesToUpdate,
    user_id: userId,
    active_program_id: undefined,
  };

  const updatePrefsResponse = await fetch(`${API_BASE_URL}/user-preferences/${userId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(prefsForFirstPut),
  });
  const updatedPrefsResult = await handleApiResponse<UserPreferencesDetail>(updatePrefsResponse);

  if (updatedPrefsResult.error) {
    accumulatedError += `Échec de la mise à jour des préférences utilisateur: ${updatedPrefsResult.error}`;
    return { error: accumulatedError.trim(), id: '', user_id: userId, name: preferencesToUpdate.name || currentFullPrefs.name || '', goal: preferencesToUpdate.goal || currentFullPrefs.goal || '', duration_weeks: 0, start_date: '' };
  }

  const genResponse = await autoGenerateNewProgram(userId, token);

  if (genResponse.error || !genResponse.program_id) {
    accumulatedError += `Préférences mises à jour, mais échec de la génération du nouveau programme: ${genResponse.error || "ID de programme manquant"}`;
    return {
      error: accumulatedError.trim(),
      id: '',
      user_id: userId,
      name: updatedPrefsResult.name || '',
      goal: updatedPrefsResult.goal || '',
      duration_weeks: 0,
      start_date: ''
    };
  }
  const newProgramId = genResponse.program_id;

  const finalPreferencesPayload: UserPreferencesPayload = {
    ...updatedPrefsResult,
    active_program_id: newProgramId,
  };

  const setActiveProgramResponse = await fetch(`${API_BASE_URL}/user-preferences/${userId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(finalPreferencesPayload),
  });
  const finalPrefsUpdateResult = await handleApiResponse<UserPreferencesDetail>(setActiveProgramResponse);

  const programDetails = await fetchProgramById(newProgramId, token);
  let sessionsArray: ProgramSession[] = [];

  if (!programDetails.error) {
      const sessionsData = await fetchSessionsWithExercisesForProgram(newProgramId, token);
      if (Array.isArray(sessionsData)) {
          sessionsArray = sessionsData;
      } else if(sessionsData.error) {
          accumulatedError += `Erreur chargement sessions du nouveau programme: ${sessionsData.error}\n`;
      }
  } else {
      accumulatedError += `Erreur chargement détails du nouveau programme: ${programDetails.error}\n`;
  }

  if (finalPrefsUpdateResult.error) {
    accumulatedError += `Programme généré (ID: ${newProgramId}) mais échec de la définition comme actif: ${finalPrefsUpdateResult.error}`;
  }

  return {
    ...(programDetails.error
      ? {
          id: newProgramId,
          user_id: userId,
          name: "Détails indisponibles",
          goal: finalPreferencesPayload.goal || "N/A",
          duration_weeks: 0,
          start_date: "",
        }
      : programDetails),
    sessions: sessionsArray,
    message: genResponse.message,
    error: accumulatedError ? accumulatedError.trim() : undefined
  };
};

export const fetchProgramById = async (
  programId: string,
  token: string
): Promise<UserProgram> => {
  const response = await fetch(`${API_BASE_URL}/programs/${programId}`, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleApiResponse<UserProgram>(response);
};

// NOUVELLE FONCTION : Récupère les détails complets d'un exercice par son ID
export const fetchExerciseDetailsById = async (
  exerciseId: string,
  token: string
): Promise<ExerciseDefinition | { error: string }> => {
  const url = `${API_BASE_URL}/exercises/${exerciseId}`; // Assurez-vous que cet endpoint existe et retourne ExerciseDefinition
  console.log(`fetchExerciseDetailsById: Appel de ${url}`);
  try {
    const response = await fetch(url, {
      method: "GET",
      headers: { Authorization: `Bearer ${token}` },
    });
    return await handleApiResponse<ExerciseDefinition | { error: string }>(response);
  } catch (error: any) {
    console.error(`fetchExerciseDetailsById: Exception pour l'exercice ${exerciseId}`, error);
    return { error: `Exception lors de la récupération des détails de l'exercice: ${error.message}` };
  }
};

// MODIFIÉ : fetchSessionsWithExercisesForProgram
// Récupère les exercices d'une session ET les enrichit avec les détails (image_url, description)
export const fetchSessionsWithExercisesForProgram = async (
  programId: string,
  token: string
): Promise<ProgramSession[] | { error: string }> => {
  const sessionsResponse = await fetch(
    `${API_BASE_URL}/sessions/program/${programId}`, // Cet endpoint retourne les sessions avec leurs listes d'exercices (basiques)
    {
      method: "GET",
      headers: { Authorization: `Bearer ${token}` },
    }
  );
  const sessionsData = await handleApiResponse<ProgramSession[] | { error: string }>(sessionsResponse);

  if ('error' in sessionsData || !Array.isArray(sessionsData)) {
    return sessionsData; // Retourne l'erreur ou si le format est incorrect
  }

  // Enrichir chaque session avec des exercices détaillés
  const enrichedSessions = await Promise.all(
    sessionsData.map(async (session) => {
      if (session.exercises && session.exercises.length > 0) {
        const enrichedExercises = await Promise.all(
          session.exercises.map(async (sessionExercise) => {
            // Les données de sessionExercise (sets, reps, rest_time) sont déjà là.
            // On a besoin de exercise_id pour récupérer image_url et description.
            if (!sessionExercise.exercise_id) {
              console.warn(`fetchSessionsWithExercisesForProgram: exercise_id manquant pour un exercice dans la session ${session.id}`);
              return sessionExercise; // Retourne l'exercice tel quel s'il manque exercise_id
            }

            const details = await fetchExerciseDetailsById(sessionExercise.exercise_id, token);
            if ('error' in details) {
              console.warn(`fetchSessionsWithExercisesForProgram: Erreur détails pour exercise_id ${sessionExercise.exercise_id}: ${details.error}`);
              // Retourne l'exercice de session avec les infos qu'on a, même si les détails ont échoué
              return {
                ...sessionExercise,
                description: sessionExercise.description || "Description non disponible", // Garde la description existante ou met un placeholder
                image_url: sessionExercise.image_url || undefined, // Garde l'image_url existante ou met undefined
              };
            }
            // Fusionne les détails (image_url, description) avec l'exercice de session
            return {
              ...sessionExercise, // Garde sets, reps, rest_time, id (de session_exercise), etc.
              name: details.name || sessionExercise.name, // Priorise le nom des détails, sinon celui de la session
              muscle_group: details.muscle_group || sessionExercise.muscle_group, // Idem pour muscle_group
              description: details.description,
              image_url: details.image_url,
            };
          })
        );
        return { ...session, exercises: enrichedExercises };
      }
      return session; // Retourne la session telle quelle si pas d'exercices
    })
  );

  return enrichedSessions;
};


// MODIFIÉ : fetchExercisesForOneSession
// Récupère les exercices pour UNE session spécifique ET les enrichit
export const fetchExercisesForOneSession = async (
  sessionId: string,
  token: string
): Promise<SessionExercise[] | { error: string }> => {
  const url = `${API_BASE_URL}/sessions/${sessionId}/exercises`; // Cet endpoint retourne la liste des SessionExercise SANS image_url/description
  console.log(`fetchExercisesForOneSession: Appel de ${url} pour la session ${sessionId}`);
  try {
    const response = await fetch(url, {
      method: "GET",
      headers: { Authorization: `Bearer ${token}` },
    });
    const basicExercisesData = await handleApiResponse<Omit<SessionExercise, 'image_url' | 'description'>[] | { error: string }>(response);

    if ('error' in basicExercisesData || !Array.isArray(basicExercisesData)) {
      console.error(`fetchExercisesForOneSession: Erreur ou format invalide pour les exercices de base de la session ${sessionId}`, basicExercisesData);
      return basicExercisesData as { error: string }; // Retourne l'erreur ou si le format est incorrect
    }
    
    if (basicExercisesData.length === 0) {
        console.log(`fetchExercisesForOneSession: Aucun exercice de base trouvé pour la session ${sessionId}`);
        return []; // Retourne un tableau vide si aucun exercice
    }

    console.log(`fetchExercisesForOneSession: Exercices de base pour session ${sessionId}:`, JSON.stringify(basicExercisesData, null, 2));

    // Enrichir chaque exercice avec les détails (image_url, description)
    const enrichedExercises = await Promise.all(
      basicExercisesData.map(async (basicExercise) => {
        if (!basicExercise.exercise_id) {
          console.warn(`fetchExercisesForOneSession: exercise_id manquant pour un exercice de la session ${sessionId}, ID de l'exercice de session: ${basicExercise.id}`);
          // Retourne l'exercice avec les infos de base si exercise_id manque
          return { 
            ...basicExercise, 
            description: "Détails non disponibles (ID exercice manquant)", 
            image_url: undefined 
          } as SessionExercise;
        }

        console.log(`fetchExercisesForOneSession: Récupération des détails pour exercise_id ${basicExercise.exercise_id} (exercice de session ${basicExercise.id})`);
        const details = await fetchExerciseDetailsById(basicExercise.exercise_id, token);

        if ('error' in details) {
          console.warn(`fetchExercisesForOneSession: Erreur lors de la récupération des détails pour exercise_id ${basicExercise.exercise_id}: ${details.error}`);
          // Retourne l'exercice de session avec les infos qu'on a, même si les détails ont échoué
          return {
            ...basicExercise,
            name: basicExercise.name, // Le nom est déjà dans basicExercise
            muscle_group: basicExercise.muscle_group, // Le muscle_group est déjà dans basicExercise
            description: "Description non disponible",
            image_url: undefined,
          } as SessionExercise;
        }
        
        // Fusionne les détails (image_url, description) avec l'exercice de session
        // basicExercise contient déjà id (de session_exercise), session_id, exercise_id, sets, reps, rest_time, name, muscle_group
        return {
          ...basicExercise,
          description: details.description,
          image_url: details.image_url,
        } as SessionExercise;
      })
    );
    console.log(`fetchExercisesForOneSession: Exercices enrichis pour session ${sessionId}:`, JSON.stringify(enrichedExercises, null, 2));
    return enrichedExercises;

  } catch (error: any) {
    console.error(`fetchExercisesForOneSession: Exception pour la session ${sessionId}`, error);
    return { error: `Exception lors de la récupération des exercices de la session: ${error.message}` };
  }
};


export type SubmitPreferencesResponse =
  | UserPreferencesResponse
  | { message: string; error?: string };

export const loginUser = async (
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await fetch(`${API_BASE_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  return handleApiResponse<AuthResponse>(response);
};

export const registerUser = async (
  email: string,
  password: string
): Promise<AuthResponse> => {
  const response = await fetch(`${API_BASE_URL}/auth/register`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  const registerData = await handleApiResponse<AuthResponse>(response);

  if (registerData.error) {
    return registerData;
  }

  const loginResponse = await fetch(`${API_BASE_URL}/auth/login`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ email, password }),
  });
  const loginData = await handleApiResponse<AuthResponse>(loginResponse);

  if (loginData.error) {
    return {
        ...registerData,
        error: `Enregistrement réussi, mais connexion auto échouée: ${loginData.error}`,
        token: undefined,
    };
  }
  return {
    ...registerData,
    token: loginData.token,
    user: loginData.user || registerData.user,
    error: undefined,
  };
};

export const fetchUserPreferences = async (
  userId: string,
  token: string
): Promise<UserPreferencesResponse> => {
  const prefsUrl = `${API_BASE_URL}/user-preferences/${userId}`;
  const response = await fetch(prefsUrl, {
    method: "GET",
    headers: { Authorization: `Bearer ${token}` },
  });
  return handleApiResponse<UserPreferencesResponse>(response);
};

export const submitUserPreferences = async (
  preferences: UserPreferencesPayload
): Promise<SubmitPreferencesResponse> => {
  const url = `${API_BASE_URL}/user-preferences`;
  const token = await AsyncStorage.getItem("token");
  if (!token) {
    return { message: "Token d'authentification non trouvé.", error: "Token d'authentification non trouvé." };
  }
  const response = await fetch(url, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(preferences),
  });
  return handleApiResponse<SubmitPreferencesResponse>(response);
};

export const autoGenerateNewProgram = async (
  userId: string,
  token: string
): Promise<{message?: string; program_id?: string; error?: string}> => {
  const payload = { user_id: userId };
  const response = await fetch(`${API_BASE_URL}/programs/auto-generate`, {
    method: "POST",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(payload),
  });
  return handleApiResponse<{message?: string; program_id?: string; error?: string}>(response);
};

export const updateUserActiveProgram = async (
  userId: string,
  currentPrefs: UserPreferencesPayload,
  activeProgramId: string,
  token: string
): Promise<UserPreferencesDetail | { error: string }> => {
  const updatePayload: UserPreferencesPayload = {
      ...currentPrefs,
      user_id: userId,
      active_program_id: activeProgramId,
  };
  const response = await fetch(`${API_BASE_URL}/user-preferences/${userId}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json", Authorization: `Bearer ${token}` },
    body: JSON.stringify(updatePayload),
  });
  return handleApiResponse<UserPreferencesDetail | { error: string }>(response);
};
